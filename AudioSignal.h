#include <vector>
#include "RIFF.h"

/**
   A class to encapsulate information about an digial audio signal
   that has been sampled using Linear Pulse Code Modulation (LPCM). An
   audio signal is essentially a series of Sample (alias for 16-bit
   integers) entries.  Example: {0, 10, 15, 10, 0, -10, -15, -10, 0}
   where each in the list is of data type Sample.  In addition to the
   actual data, each audio signal also contains the following meta
   data associated with the signal:

   <ul>

   <li>sampleRate: This value determines the number of samples that
   constitutes one (actual) second of audio signal. For example, if
   the sampel rate is 1000 then one thousand consecutive numbers
   provide the necessary data to construct 1 second of audio.
   Typically the sample rates are at least 8000 for decent quality
   spoken audio and can be as high as 44100 for CD quality music.</li>

   <li>bitsPerSample: This value determines the minimum and maximum
   values for each sample in the actual aduio signal/wave.  Currently,
   only 8-bit and 16-bit values are used. 8-bits limit the range of
   each sample to -128 to +127.  On the other hand, 16-bit values
   provide higher fidelity reproduction by proving a range from -65536
   to +65535.  Typically 16-bit values are used to provide a good
   dynamic range and fidelity of music.  Read more information about
   this topic of quality via Wikipedia article: <a
   href="http://en.wikipedia.org/wiki/Audio_bit_depth">http://en.wikipedia.org/wiki/Audio_bit_depth</a>.</li>
   
   </ul>
*/
class AudioSignal {
private:
    int   sampleRate;         // Number of samples per second
    short bitsPerSample;      // Bits per sample. Can be 8-bits or 16-bits
    std::vector<Sample> wave; // The actual data for this audio signal
    
public:
    /**
       Constructor to create a audio signal with a given sample rate
       and bits per sample.

       This constructor creates an audio signal that does not have any
       wave (or actual sound data) associated with it.

       \param[in] sampleRate The sampling rate for this audio
       signal. The sampling rate indicates the the number of samples
       for each second of this audio signal.

       \param[in] bitsPerSample The number of bits/bytes occupied by
       each entry in the audio wave associated with this signal. This
       value must be either 8 or 16.
    */
    AudioSignal(const int sampleRate = 22050, const short bitsPerSample = 16);

    /**
       This constructor creates an sinusoidal audio signal of the
       given frequency, maximum amplitude, sample rate, and bits per
       sample.

       \param[in] freq The frequency of the audio signal to be
       generated by this method.  If the frequency is 10 Hz and the
       lenInMills is 1000 (one second long) then this method generates
       10 full sine waves in the given samples.

       \param[in] lenInMills The length of the audio signal in
       milliseconds,

       \param[in] amplitude The maximum amplitude of the signal.
       
       \param[in] sampleRate The sampling rate for this audio
       signal. The sampling rate indicates the the number of samples
       for each second of this audio signal.
       
       \param[in] bitsPerSample The number of bits/bytes occupied by
       each entry in the audio wave associated with this signal. This
       value must be either 8 or 16.

       \param[in] decay If this parameter is true then the amplitude
       of the audio signal is exponentially decayed to simulate
       striking of real musical string instrument.
    */
    AudioSignal(const int freq, const int lenInMills, const int amplitude,
                const int sampleRate = 22050, const short bitsPerSample = 16,
                const bool decay = true);
    
    /**
       Constructor to create a audio signal from a given RIFF file.

       This constructor creates an audio signal by loading the
       necessary information from a given ".wav"/RIFF file.

       \note Do not use istream_iterator to read data. Use standard
       while loop as shown in RIFFReader API documentation.
       
       \param[in] inputWaveFile The RIFF file stream from where the
       sample rate, bitsPerSample, and audio wave data are to be
       read into this audio signal.
    */
    AudioSignal(RIFFReader& inputWaveFile);

    /**
       Copy constructor.
       
       Copy constructor to make a copy of a given source Audio Signal.
       
       \param[in] src The soruce signal from where all the instance
       variables are to be copied to this class.
    */
    AudioSignal(const AudioSignal& src);
    
    /**
       Move constructor.
       
       The move constructor that initializes this object by moving
       data from the given source audio signal.
       
       \param[in,out] src The source audio signal from where the data
       for this audio signal is to be copied.
    */
    AudioSignal(AudioSignal&& src);

    /** Assignment operator.

        Copies all the necessary information from the supplied source
        audio signal into this.

        \param[in] src The audio signal from where the data is to be
        copied.

        \return A reference to this.
     */
    AudioSignal& operator=(const AudioSignal& src);
    
    /** Constructively superposition individual samples from this
        audio stream and another to create a new audio signal.

        This method is used to superposition this audio signal with
        another audio signal to create and return a new audio
        signal. For example if this audio signal has wave data {1, 2,
        3, ...} and the other audio signal has wave data {4, -2, 6,
        ...} the resulting audio stream has the data {7, 0, 9, ....}.
        This method assumes that the two signals have the same sample
        rate. The resulting aduio stream has the higher of the two
        bitsPerSample -- that is, superimposing a 8-bits-per-sample
        and a 16-bits-per-sample audio signal results in a
        16-bits-per-sample audio wave.

        \param[in] other The other audio signal to be superimposed on
        this wave.

        \return A new audio signal that is a constructive
        superposition of the two given audio signals.
    */
    AudioSignal operator+(const AudioSignal& other) const;

    /** Method to concatenate another audio signal onto this signal.

        This method provides implementation for the ampersand operator
        to append another signal to the end of this signal.  For
        example if this audio signal has wave data {1, 2, 3} and the
        other audio signal has wave data {100, 200, 300}, then this
        method converts this to {1, 2, 3, 100, 200, 300}.

        \param[in] other The other signal to be appended to the this
        signal.

        \return A reference to this signal that has other signal
        values appended to it.
    */
    AudioSignal& operator&=(const AudioSignal& other);
    
    /** Destructively superposition individual samples from this audio
        stream and another to create a new audio signal.

        This method is used to destructively superposition this audio
        signal with another audio signal to create and return a new
        audio signal. For example if this audio signal has wave data
        {1, 2, 6, ...} and the other audio signal has wave data {4,
        -2, 3, ...} the resulting audio stream has the data {-3, 4, 3,
        ....}.  This method assumes that the two signals have the same
        sample rate. The resulting aduio stream has the higher of the
        two bitsPerSample -- that is, superimposing a
        8-bits-per-sample and a 16-bits-per-sample audio signal
        results in a 16-bits-per-sample audio wave.

        \param[in] other The other audio signal to be negatively
        superposition on this wave.
    */
    AudioSignal operator-(const AudioSignal& other) const;

    /** Amplify/reduce (or scale) each sample in this signal by the
        given factor.

        This method is used to suitably scale each sample in the given
        audio scale. For example if this aduio signal has wave data
        {2, -4, 6, ...} and the scale factor is 2.0 then samples in \c
        this wave should be modified to {4, -8, 12, ....}.

		\note This method modifies \c this object and does not create
		a new object.
		
        \param[in] factor The scale factor. If the factor is greater
        than 1 then the signal is amplified.  If the factor is less
        than 1 then the signal is reduced.

		\return This method returns a reference to this object.
    */
    AudioSignal& operator*=(double factor);

    /** Shift the audio signal to the right by the given amount of
        time (in milliseconds).

        This method shifts the audio signal by the necessary number of
        samples (given the sampling rate and the timeInMillis) by
        inserting zeros at the beginning of the wave.  For example if
        this audio signal has wave data {5, -17, 25, 3, ....} then
        shifting it to the right by 1 millisecond (assuming it results
        in requiring to add 5 samples) results in a new audio signal
        with the wave data {0, 0, 0, 0, 0, 5, -17, 25, 3, ...}.

        \param[in] timeInMillis The time in milliseconds by which the
        audio signal is to be shifted to the right.
    */
    AudioSignal operator>>(long timeInMillis) const;

    /** Shift the audio signal to the left by the given amount of
        time (in milliseconds).

        This method shifts the audio signal by the necessary number of
        samples (given the sampling rate and the timeInMillis) by
        removing samples at the beginning of the wave.  For example if
        this audio signal has wave data {5, -17, 25, 3, -9, 0, 15,
        ....} then shifting it to the left by 1 millisecond (assuming
        it results in requiring to remove 5 samples) results in a new
        audio signal with the wave data {0, 15, ...}.

        \param[in] timeInMillis The time in milliseconds by which the
        audio signal is to be shifted to the left.
    */
    AudioSignal operator<<(long timeInMillis) const;

    /** Write the audio data in this signal to a ".wav" file.

        This method must create a suitable RIFFWriter stream and write
        the audio data in this signal to the file.

        \note Do note use a ostream_iterator.  Use a for-each loop to
        write the data to a RIFFWriter.
        
        \param[in] fileName The name of the file to which the audio
        data in this signal is to be written in RIFF format.

        \exception std::exception This method just exposes the
        exceptions that may be generated by the various methods called
        by this method.
    */
    void write(const std::string& fileName) const throw (std::exception);

    /** Returns the duration of this audio signal in milliseconds.

        \return This method returns the duration of this aduio signal
        in milliseconds.
    */
    long duration() const;

    /** Increase or decrease the duration of this audio signal to the
        given duration of time.

        This method changes \c this audio signal such that the
        duration of the signal is changed to the specified value
        (first parameter to this method) depending on the current
        duration of the signal in the one of the following two ways:
        
        <ul>

        <li>If the current signal is shorter than the specified
        duration, then the current signal is replicated (or repeated)
        until the desired duration of samples is obtained.</li>
        
        <li>If the current signal is
        longer than the specified duration then the signal is
        truncated (by simply discarding samples at the end of the
        signal) to the necessary duration. </li>

        </ul>

        \param[in] timeInMills The final desired duration (in
        milliseconds) of this audio signal
    */
    void changeDurationTo(const int timeInMillis);
    
protected:
    // This class does not have any protected members
};
